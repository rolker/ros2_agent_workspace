#!/usr/bin/env python3
"""
Build Report Generator for ROS2 Agent Workspace

This script parses colcon's events.log file and generates a markdown table row
summarizing the build results for a single workspace layer.

Usage:
    python3 build_report_generator.py --log-dir <path> --layer-name <name>

Output:
    Prints a markdown table row with:
    - Layer name
    - Package counts (total/successful)
    - Failed/warning packages
    - Status emoji

Security Note:
    This script uses eval() to parse Python repr() output from colcon logs.
    This is acceptable since the logs are generated locally by colcon, but
    be cautious when processing logs from untrusted sources.
"""

import argparse
import os

# Try to import colcon-core if available, otherwise we might need to parse manually or warn.
# For simplicity in this environment, we will assume standard python
# libraries and minimal dependencies or parse the log lines as python
# literals since they are string representations of dicts/tuples.
# The logs look like: [timestamp] (name) EventType: {data}


def parse_args():
    parser = argparse.ArgumentParser(description="Generate build report from colcon events.log")
    parser.add_argument(
        "--log-dir", required=True, help="Path to the directory containing events.log"
    )
    parser.add_argument("--layer-name", required=True, help="Name of the workspace layer")
    return parser.parse_args()


def parse_log_line(line):
    """
    Rudimentary parser for colcon log lines.
    Format: [timestamp] (package_name) EventType: {data_repr}
    """
    try:
        # Split by first ' ' then first ' ' then first ': '
        # Example: [0.000463] (command_bridge) JobQueued: {'identifier': ...}

        # Find closing bracket of timestamp
        t_end = line.find("] ")
        if t_end == -1:
            return None

        remaining = line[t_end + 2 :]  # (pkg_name) EventType: {...}

        # Find end of package name
        p_end = remaining.find(") ")
        if p_end == -1:
            return None

        pkg_name = remaining[1:p_end]
        remaining = remaining[p_end + 2 :]  # EventType: {...}

        # Find event type separator
        e_end = remaining.find(": ")
        if e_end == -1:
            return None

        event_type = remaining[:e_end]
        data_str = remaining[e_end + 2 :]

        # Safe eval is tricky, but the logs are generated by python repr().
        # We handle basic types.
        # Ideally we'd use a regex or json if it were json, but it is python repr.
        # We will try to rely on simple string searching for safety,
        # or `eval` if strictly controlled (risky but easy).
        # Given this is a local build tool, `eval` on the log content
        # is acceptable for this prototype but we should be careful.

        data = eval(data_str)
        return pkg_name, event_type, data

    except Exception:
        return None


def main():
    args = parse_args()
    log_file = os.path.join(args.log_dir, "events.log")

    if not os.path.exists(log_file):
        print(f"| {args.layer_name} | 0 | - | ⚠️ Log Not Found |")
        return

    packages = set()
    failed_packages = set()
    stderr_packages = set()

    # Track completion to ensure we don't count skipped/aborted as success blindly
    # Dictionary of pkg -> return_code
    results = {}

    with open(log_file, "r") as f:
        for line in f:
            parsed = parse_log_line(line.strip())
            if not parsed:
                continue

            pkg_name, event_type, data = parsed

            # Identify all packages
            if event_type == "JobQueued":
                packages.add(pkg_name)

            # Check for job completion
            if event_type == "JobEnded":
                rc = data.get("rc", 0)
                results[pkg_name] = rc
                if rc != 0:
                    failed_packages.add(pkg_name)

            # Check for persistent stderr (warnings or errors)
            if event_type == "StderrLine":
                stderr_packages.add(pkg_name)

    # Compile Summary
    total = len(packages)
    failed_count = len(failed_packages)
    success_count = total - failed_count

    # Determine status icon
    if failed_count > 0:
        status = "❌ Failed"
    elif total == 0:
        status = "⚠️ No Pkgs"
    else:
        status = "✅ Success"

    # Formatting lists
    failed_list = ", ".join(sorted(list(failed_packages))) if failed_packages else "-"
    stderr_list = ", ".join(sorted(list(stderr_packages))) if stderr_packages else "-"

    if failed_packages:
        # If failed, we highlight the failed ones in the output column preferentially
        output_col = f"**Failed**: {failed_list}"
        if stderr_packages:
            # Add other warnings if needed, but failures are priority
            # Remove failed from stderr to just see "warnings"
            warnings = stderr_packages - failed_packages
            if warnings:
                output_col += f"<br/>**Warnings**: {', '.join(sorted(list(warnings)))}"
    else:
        output_col = stderr_list if stderr_packages else "-"

    # Output Markdown Row
    # | Layer | Packages (Total/Success) | Output (Warnings/Errors) | Status |
    print(f"| {args.layer_name} | {total} (OK: {success_count}) | {output_col} | {status} |")


if __name__ == "__main__":
    main()
